///////////////////////////////////////////////////////////////////////////////
// File generated by HDevelop for HALCON/C++ Version 24.11.1.0
// Non-ASCII strings in this file are encoded in local-8-bit encoding (cp936).
// Ensure that the interface encoding is set to locale encoding by calling
// SetHcppInterfaceStringEncodingIsUtf8(false) at the beginning of the program.
// 
// Please note that non-ASCII characters in string constants are exported
// as octal codes in order to guarantee that the strings are correctly
// created on all systems, independent on any compiler settings.
// 
// Source files with different encoding should not be mixed in one project.
///////////////////////////////////////////////////////////////////////////////
#include "HalconCpp.h"
#include "HDevThread.h"



using namespace HalconCpp;

// Procedure declarations 
// Chapter: Develop
// Short Description: Open a new graphics window that preserves the aspect ratio of the given image. 
void dev_open_window_fit_image (HObject ho_Image, HTuple hv_Row, HTuple hv_Column, 
    HTuple hv_WidthLimit, HTuple hv_HeightLimit, HTuple *hv_WindowHandle);

// Procedures 
// Chapter: Develop
// Short Description: Open a new graphics window that preserves the aspect ratio of the given image. 
void dev_open_window_fit_image (HObject ho_Image, HTuple hv_Row, HTuple hv_Column, 
    HTuple hv_WidthLimit, HTuple hv_HeightLimit, HTuple *hv_WindowHandle)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_MinWidth, hv_MaxWidth, hv_MinHeight;
  HTuple  hv_MaxHeight, hv_ResizeFactor, hv_ImageWidth, hv_ImageHeight;
  HTuple  hv_TempWidth, hv_TempHeight, hv_WindowWidth, hv_WindowHeight;

  //This procedure opens a new graphics window and adjusts the size
  //such that it fits into the limits specified by WidthLimit
  //and HeightLimit, but also maintains the correct image aspect ratio.
  //
  //If it is impossible to match the minimum and maximum extent requirements
  //at the same time (f.e. if the image is very long but narrow),
  //the maximum value gets a higher priority,
  //
  //Parse input tuple WidthLimit
  if (0 != (HTuple(int((hv_WidthLimit.TupleLength())==0)).TupleOr(int(hv_WidthLimit<0))))
  {
    hv_MinWidth = 500;
    hv_MaxWidth = 800;
  }
  else if (0 != (int((hv_WidthLimit.TupleLength())==1)))
  {
    hv_MinWidth = 0;
    hv_MaxWidth = hv_WidthLimit;
  }
  else
  {
    hv_MinWidth = ((const HTuple&)hv_WidthLimit)[0];
    hv_MaxWidth = ((const HTuple&)hv_WidthLimit)[1];
  }
  //Parse input tuple HeightLimit
  if (0 != (HTuple(int((hv_HeightLimit.TupleLength())==0)).TupleOr(int(hv_HeightLimit<0))))
  {
    hv_MinHeight = 400;
    hv_MaxHeight = 600;
  }
  else if (0 != (int((hv_HeightLimit.TupleLength())==1)))
  {
    hv_MinHeight = 0;
    hv_MaxHeight = hv_HeightLimit;
  }
  else
  {
    hv_MinHeight = ((const HTuple&)hv_HeightLimit)[0];
    hv_MaxHeight = ((const HTuple&)hv_HeightLimit)[1];
  }
  //
  //Test, if window size has to be changed.
  hv_ResizeFactor = 1;
  GetImageSize(ho_Image, &hv_ImageWidth, &hv_ImageHeight);
  //First, expand window to the minimum extents (if necessary).
  if (0 != (HTuple(int(hv_MinWidth>hv_ImageWidth)).TupleOr(int(hv_MinHeight>hv_ImageHeight))))
  {
    hv_ResizeFactor = (((hv_MinWidth.TupleReal())/hv_ImageWidth).TupleConcat((hv_MinHeight.TupleReal())/hv_ImageHeight)).TupleMax();
  }
  hv_TempWidth = hv_ImageWidth*hv_ResizeFactor;
  hv_TempHeight = hv_ImageHeight*hv_ResizeFactor;
  //Then, shrink window to maximum extents (if necessary).
  if (0 != (HTuple(int(hv_MaxWidth<hv_TempWidth)).TupleOr(int(hv_MaxHeight<hv_TempHeight))))
  {
    hv_ResizeFactor = hv_ResizeFactor*((((hv_MaxWidth.TupleReal())/hv_TempWidth).TupleConcat((hv_MaxHeight.TupleReal())/hv_TempHeight)).TupleMin());
  }
  hv_WindowWidth = hv_ImageWidth*hv_ResizeFactor;
  hv_WindowHeight = hv_ImageHeight*hv_ResizeFactor;
  //Resize window
  SetWindowAttr("background_color","black");
  OpenWindow(hv_Row,hv_Column,hv_WindowWidth,hv_WindowHeight,0,"visible","",&(*hv_WindowHandle));
  HDevWindowStack::Push((*hv_WindowHandle));
  if (HDevWindowStack::IsOpen())
    SetPart(HDevWindowStack::GetActive(),0, 0, hv_ImageHeight-1, hv_ImageWidth-1);
  return;
}

#ifndef NO_EXPORT_MAIN
// Main procedure 
void action()
{

  // Local iconic variables
  HObject  ho_nccImage, ho_nccGrayImage, ho_nccRectangle;
  HObject  ho_nccImageReduced, ho_nccGrayImage1, ho_nccRectangle1;

  // Local control variables
  HTuple  hv_WindowHandle2, hv_nccRow1, hv_nccColumn1;
  HTuple  hv_nccRow2, hv_nccColumn2, hv_nccModelID, hv_nccRow;
  HTuple  hv_nccColumn, hv_nccAngle, hv_nccScore, hv_nccNumber;
  HTuple  hv_i, hv_scorenccmsg, hv_rownccmsg, hv_columnnccmsg;
  HTuple  hv_Font, hv_FontWithSize, hv_ccc;

  if (HDevWindowStack::IsOpen())
    CloseWindow(HDevWindowStack::Pop());
  ReadImage(&ho_nccImage, "dog.jpg");
  //打开一个适合图像大小的窗口
  dev_open_window_fit_image(ho_nccImage, 0, 0, -1, -1, &hv_WindowHandle2);
  if (HDevWindowStack::IsOpen())
    DispObj(ho_nccImage, HDevWindowStack::GetActive());
  //灰度
  Rgb1ToGray(ho_nccImage, &ho_nccGrayImage);
  //画笔设置 'margin'不填充
  if (HDevWindowStack::IsOpen())
    SetDraw(HDevWindowStack::GetActive(),"margin");
  if (HDevWindowStack::IsOpen())
    SetLineWidth(HDevWindowStack::GetActive(),3);
  if (HDevWindowStack::IsOpen())
    SetColor(HDevWindowStack::GetActive(),"red");

  //画矩形
  DrawRectangle1(hv_WindowHandle2, &hv_nccRow1, &hv_nccColumn1, &hv_nccRow2, &hv_nccColumn2);
  GenRectangle1(&ho_nccRectangle, hv_nccRow1, hv_nccColumn1, hv_nccRow2, hv_nccColumn2);
  if (HDevWindowStack::IsOpen())
    DispObj(ho_nccRectangle, HDevWindowStack::GetActive());
  //抠图
  ReduceDomain(ho_nccGrayImage, ho_nccRectangle, &ho_nccImageReduced);
  //创建ncc模版    模板，金字塔等级的最大数量，起始角度，角度步长，模型ID
  CreateNccModel(ho_nccImageReduced, 5, -0.39, 0.79, "auto", "use_polarity", &hv_nccModelID);

  ReadImage(&ho_nccImage, "dog.jpg");
  Rgb1ToGray(ho_nccImage, &ho_nccGrayImage1);
  if (HDevWindowStack::IsOpen())
    DispObj(ho_nccGrayImage1, HDevWindowStack::GetActive());
  //应用模板进行匹配 灰度图像，模型ID，起始角度，角度范围，匹配度，目标个数，最大重叠，子像素精度，金字塔等级数，
  FindNccModel(ho_nccGrayImage1, hv_nccModelID, -0.39, 0.79, 0.50, 0, 0.4, "true", 
      5, &hv_nccRow, &hv_nccColumn, &hv_nccAngle, &hv_nccScore);
  GenRectangle1(&ho_nccRectangle1, hv_nccRow-((hv_nccRow2-hv_nccRow1)/2), hv_nccColumn-((hv_nccColumn2-hv_nccColumn1)/2), 
      hv_nccRow+((hv_nccRow2-hv_nccRow1)/2), hv_nccColumn+((hv_nccColumn2-hv_nccColumn1)/2));
  CountObj(ho_nccRectangle1, &hv_nccNumber);

  {
  HTuple end_val29 = hv_nccNumber;
  HTuple step_val29 = 1;
  for (hv_i=1; hv_i.Continue(end_val29, step_val29); hv_i += step_val29)
  {
    hv_scorenccmsg = HTuple(hv_nccScore[hv_i-1]);
    hv_rownccmsg = HTuple(hv_nccRow[hv_i-1]);
    hv_columnnccmsg = HTuple(hv_nccColumn[hv_i-1]);
    //stop ()
  }
  }
  if (HDevWindowStack::IsOpen())
    DispObj(ho_nccImage, HDevWindowStack::GetActive());
  if (HDevWindowStack::IsOpen())
    DispObj(ho_nccRectangle1, HDevWindowStack::GetActive());
  QueryFont(hv_WindowHandle2, &hv_Font);
  hv_FontWithSize = HTuple(hv_Font[0])+"-10";
  SetFont(hv_WindowHandle2, hv_FontWithSize);
  //set_display_font (WindowHandle2, 10, 'mono', 'true', 'false')
  //disp_message (WindowHandle2, ['Score: ' + nccScore], 'image', nccRow, nccColumn, 'black', 'true')
  if (HDevWindowStack::IsOpen())
    DispText(HDevWindowStack::GetActive(),hv_nccRow, "image", hv_nccRow+20, hv_nccColumn, 
        "black", HTuple(), HTuple());
  if (HDevWindowStack::IsOpen())
    DispText(HDevWindowStack::GetActive(),hv_nccColumn, "image", hv_nccRow+40, hv_nccColumn, 
        "black", HTuple(), HTuple());
  hv_ccc = hv_nccScore;
  //释放ncc模版资源
  ClearNccModel(hv_nccModelID);
}


#ifndef NO_EXPORT_APP_MAIN


int main(int argc, char *argv[])
{
  int ret = 0;

  try
  {
#if defined(_WIN32)
    SetSystem("use_window_thread", "true");
#endif

    // file was stored with local-8-bit encoding
    //   -> set the interface encoding accordingly
    SetHcppInterfaceStringEncodingIsUtf8(false);

    // Default settings used in HDevelop (can be omitted)
    SetSystem("width", 512);
    SetSystem("height", 512);

    action();
  }
  catch (HException &exception)
  {
    fprintf(stderr,"  Error #%u in %s: %s\n", exception.ErrorCode(),
            exception.ProcName().TextA(),
            exception.ErrorMessage().TextA());
    ret = 1;
  }

#if defined(_WIN32)
  // On Windows socket communication is no longer possible after returning
  // from main, so HALCON cannot return floating licenses automatically.
  try
  {
    SetSystem("return_license", "true");
  }
  catch (...)
  {
    // Ignore any errors that might occur when returning the license.
  }
#endif

  return ret;
}

#endif


#endif


